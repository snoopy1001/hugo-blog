---
title: "[笔记] SQL 窗口函数总结"
date: 2020-10-01
lastmod: 2020-10-10
draft: false
tags: ["窗口函数", "数据库", "SQL"]
categories: ["SQL"]

---



{{% admonition 更新说明 更新说明 %}} 

2020-10-10 新增 [使用 Hive SQL 的窗口函数进行商务数据分析](https://jiamaoxiang.top/2020/09/07/%E4%BD%BF%E7%94%A8Hive-SQL%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%95%86%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/)

2020-10-01 新增 [MySQL 窗口函数](https://tding.top/archives/c6e31643.html) 

2020-10-01 修订 部分文字和排版

 {{% /admonition %}}




## 1. 窗口函数的简介



**窗口函数**是为了实现 OLAP 而添加的标准 SQL 功能，也称为 OLAP 函数（OnLine Analytical Processing 的简称，指 [**联机分析处理**](https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86) ），其作用是将表以窗口为单位进行分割，并在其中进行排序。

😘**注意**：从 **MySQL 8.0** 开始支持窗口函数。

窗口函数和普通聚合函数很容易混淆，二者区别如下：

- **聚合函数是将多条记录聚合为一条；而窗口函数是每条记录都会执行，有几条记录执行完还是几条**。
- 聚合函数也可以用于窗口函数中。

## 2. 窗口函数的语法

```sql
# [] 中的内容可以省略
<窗口函数> OVER ([PARTITION BY <列清单>] ORDER BY <排序用列清单>)
```

小结：窗口函数兼具分组和排序两种功能，通过 `PARTITION BY` 分组后的记录集合称为“窗口”，`PARTITION BY` 设定排序的对象范围，`ORDER BY` 指定按照哪一列、何种顺序进行排序。

思考： PARTITION BY 和 GROUP BY 的区别 

 `PARTITION BY` 返回分组里的每一行数据，`GROUP BY` 返回分组里的仅一行数据




## 3. 窗口函数的类型

一般按照功能划分可将窗口函数分为聚合窗口函数和专门窗口函数（如排名窗口函数）。



### 3.1 聚合窗口函数

> 以**当前记录**作为基准进行**累计**，是聚合窗口函数的最大特征

指定 “最靠近的 3 行” 作为汇总对象，输入以下测试代码：

```sql
# 指定 “最靠近的 3 行” 作为汇总对象
SELECT product_id, product_name, sale_price,
	AVG (sale_price) OVER (ORDER BY product_id ROWS 2 PRECEDING) AS moving_avg
FROM Product;
```

其结果输出：


| product_id | product_name | sale_price | moving_avg |
| ---------  | ------------ | ---------  | ---------   |
|       0001 | T恤衫         |       1000 |       1000 |
|       0002 | 打孔器        |        500 |        750 |
|       0003 | 运动T恤       |       4000 |       1833 |
|       0004 | 菜刀         |       3000 |       2500 |
|       0005 | 高压锅       |       6800 |       4600 |
|       0006 | 叉子         |        500 |       3433 |
|       0007 | 擦菜板       |        880 |       2726 |
|       0008 | 圆珠笔       |        100 |        493 |

将当前记录的前后行作为汇总对象，SQL 语句如下：

```sql
# 将当前记录的前后行作为汇总对象
SELECT product_id, product_name, sale_price,
	AVG(sale_price) OVER(ORDER BY product_id 
	ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS moving_avg 
FROM Product;
```

输出结果：

| product_id | product_name | sale_price | moving_avg |
| ---------: | ------------ | ---------: | ---------: |
|       0001 | T恤衫        |       1000 |        750 |
|       0002 | 打孔器       |        500 |       1833 |
|       0003 | 运动T恤      |       4000 |       2500 |
|       0004 | 菜刀         |       3000 |       4600 |
|       0005 | 高压锅       |       6800 |       3433 |
|       0006 | 叉子         |        500 |       2726 |
|       0007 | 擦菜板       |        880 |        493 |
|       0008 | 圆珠笔       |        100 |        490 |



😀说明：`ROWS` 指定框架，`PRECEDING` 将框架指定为“截止到之**前** ~ 行”，`FOLLOWING`  将框架指定为“截止到之**后** ~ 行”



### 3.2 排名窗口函数



排名窗口函数测试代码：

```sql
SELECT product_name, product_type, sale_price,
	RANK () OVER (ORDER BY sale_price) AS ranking,
	DENSE_RANK () OVER (ORDER BY sale_price) AS dense_ranking,
	ROW_NUMBER () OVER (ORDER BY sale_price) AS row_num
FROM Product;
```

结果输出：

| product_name | product_type | sale_price | ranking | dense_ranking | row_num |
| ------------ | ------------ | ---------: | ------: | ------------: | ------: |
| 圆珠笔       | 办公用品     |        100 |       1 |             1 |       1 |
| 叉子         | 厨房用具     |        500 |       2 |             2 |       2 |
| 打孔器       | 办公用品     |        500 |       2 |             2 |       3 |
| 擦菜板       | 厨房用具     |        880 |       4 |             3 |       4 |
| T恤衫        | 衣服         |       1000 |       5 |             4 |       5 |
| 菜刀         | 厨房用具     |       3000 |       6 |             5 |       6 |
| 运动T恤      | 衣服         |       4000 |       7 |             6 |       7 |
| 高压锅       | 厨房用具     |       6800 |       8 |             7 |       8 |



### 3.3 MySQL 支持的窗口函数

按照功能划分，可以把 MySQL 支持的窗口函数分为如下几类：

- 序号函数：row_number () /rank () /dense_rank ()
- 分布函数：percent_rank () /cume_dist ()
- 前后函数：lag () /lead ()
- 头尾函数：first_val () /last_val ()
- 其他函数：nth_value () /nfile ()

分布函数 cume_dist ()

用途：分组内大于等于当前 rank 值的行数 / 分组内总行数。

应用场景：大于等于当前订单金额的订单比例有多少。

```sql
select 
rank() over w as row_num,
cume_dist() over w as percent,
order_id,user_no,amount,create_date
from order_info
window w as (partition by user_no order by amount desc);
+---------+---------+----------+---------+--------+---------------------+
| row_num | percent | order_id | user_no | amount | create_date         |
+---------+---------+----------+---------+--------+---------------------+
|       1 |     0.2 |        5 | u0001   |    900 | 2018-01-20 00:00:00 |
|       2 |     0.4 |        4 | u0001   |    800 | 2018-01-10 00:00:00 |
|       3 |     0.8 |        2 | u0001   |    300 | 2018-01-02 00:00:00 |
|       3 |     0.8 |        3 | u0001   |    300 | 2018-01-02 00:00:00 |
|       5 |       1 |        1 | u0001   |    100 | 2018-01-01 00:00:00 |
|       1 |     0.4 |        9 | u0002   |    800 | 2018-01-16 00:00:00 |
|       1 |     0.4 |       10 | u0002   |    800 | 2018-01-22 00:00:00 |
|       3 |     0.6 |        7 | u0002   |    600 | 2018-01-06 00:00:00 |
|       4 |     0.8 |        6 | u0002   |    500 | 2018-01-05 00:00:00 |
|       5 |       1 |        8 | u0002   |    300 | 2018-01-10 00:00:00 |
+---------+---------+----------+---------+--------+---------------------+
```

前后函数 lag ()、lead ()

用途：

- lag (column,n) 获取当前数据行按照某种排序规则的上 n 行数据的某个字段
- lead (column,n) 获取当前数据行按照某种排序规则的下 n 行数据的某个字段

应用场景：按照时间排序，获取当前订单的上一笔订单发生时间和下一笔订单发生时间，（可以计算订单的时间上的间隔度或者说买买买的频繁程度）。

```sql
select 
order_id,user_no,amount,create_date,
lag(create_date,1) over w 'last_transaction_time',
lead(create_date,1) over w 'next_transaction_time'
from order_info
window w as (partition by user_no order by create_date asc);
+----------+---------+--------+---------------------+-----------------------+-----------------------+
| order_id | user_no | amount | create_date         | last_transaction_time | next_transaction_time |
+----------+---------+--------+---------------------+-----------------------+-----------------------+
|        1 | u0001   |    100 | 2018-01-01 00:00:00 | NULL                  | 2018-01-02 00:00:00   |
|        2 | u0001   |    300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00   | 2018-01-02 00:00:00   |
|        3 | u0001   |    300 | 2018-01-02 00:00:00 | 2018-01-02 00:00:00   | 2018-01-10 00:00:00   |
|        4 | u0001   |    800 | 2018-01-10 00:00:00 | 2018-01-02 00:00:00   | 2018-01-20 00:00:00   |
|        5 | u0001   |    900 | 2018-01-20 00:00:00 | 2018-01-10 00:00:00   | NULL                  |
|        6 | u0002   |    500 | 2018-01-05 00:00:00 | NULL                  | 2018-01-06 00:00:00   |
|        7 | u0002   |    600 | 2018-01-06 00:00:00 | 2018-01-05 00:00:00   | 2018-01-10 00:00:00   |
|        8 | u0002   |    300 | 2018-01-10 00:00:00 | 2018-01-06 00:00:00   | 2018-01-16 00:00:00   |
|        9 | u0002   |    800 | 2018-01-16 00:00:00 | 2018-01-10 00:00:00   | 2018-01-22 00:00:00   |
|       10 | u0002   |    800 | 2018-01-22 00:00:00 | 2018-01-16 00:00:00   | NULL                  |
+----------+---------+--------+---------------------+-----------------------+-----------------------+
```



头尾函数 first_value ()、last_value ()

用途：头尾函数可以得到分区中的第一个 / 最后一个指定参数的值。

应用场景：查询截止到当前订单，按照日期排序第一个订单和最后一个订单的订单金额。

```sql
select 
order_id,user_no,amount,create_date,
first_value(create_date) over w 'first_transaction_time',
last_value(create_date) over w 'last_transaction_time'
from order_info
window w as (partition by user_no order by create_date asc);
+----------+---------+--------+---------------------+------------------------+-----------------------+
| order_id | user_no | amount | create_date         | first_transaction_time | last_transaction_time |
+----------+---------+--------+---------------------+------------------------+-----------------------+
|        1 | u0001   |    100 | 2018-01-01 00:00:00 | 2018-01-01 00:00:00    | 2018-01-01 00:00:00   |
|        2 | u0001   |    300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00    | 2018-01-02 00:00:00   |
|        3 | u0001   |    300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00    | 2018-01-02 00:00:00   |
|        4 | u0001   |    800 | 2018-01-10 00:00:00 | 2018-01-01 00:00:00    | 2018-01-10 00:00:00   |
|        5 | u0001   |    900 | 2018-01-20 00:00:00 | 2018-01-01 00:00:00    | 2018-01-20 00:00:00   |
|        6 | u0002   |    500 | 2018-01-05 00:00:00 | 2018-01-05 00:00:00    | 2018-01-05 00:00:00   |
|        7 | u0002   |    600 | 2018-01-06 00:00:00 | 2018-01-05 00:00:00    | 2018-01-06 00:00:00   |
|        8 | u0002   |    300 | 2018-01-10 00:00:00 | 2018-01-05 00:00:00    | 2018-01-10 00:00:00   |
|        9 | u0002   |    800 | 2018-01-16 00:00:00 | 2018-01-05 00:00:00    | 2018-01-16 00:00:00   |
|       10 | u0002   |    800 | 2018-01-22 00:00:00 | 2018-01-05 00:00:00    | 2018-01-22 00:00:00   |
+----------+---------+--------+---------------------+------------------------+-----------------------+
```



😱注意：如果不加 `order by`, 就没有窗口，计算范围是整个分区；如果加上 `order by`, 默认窗口是 `range between unbounded preceding and current row`，就是排序后从分区第一行一直到当前行为止。

由于我们需要求的是每个用户的第一个和最后一个订单，所以这里要指定窗口：从第一行 `unbounded preceding` 到最后一行 `unbounded following`。

```sql
select 
order_id,user_no,amount,create_date,
first_value(create_date) over w 'first_transaction_time',
last_value(create_date) over w 'last_transaction_time'
from order_info
window w as (partition by user_no order by create_date asc rows between unbounded preceding and unbounded following);
+----------+---------+--------+---------------------+------------------------+-----------------------+
| order_id | user_no | amount | create_date         | first_transaction_time | last_transaction_time |
+----------+---------+--------+---------------------+------------------------+-----------------------+
|        1 | u0001   |    100 | 2018-01-01 00:00:00 | 2018-01-01 00:00:00    | 2018-01-20 00:00:00   |
|        2 | u0001   |    300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00    | 2018-01-20 00:00:00   |
|        3 | u0001   |    300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00    | 2018-01-20 00:00:00   |
|        4 | u0001   |    800 | 2018-01-10 00:00:00 | 2018-01-01 00:00:00    | 2018-01-20 00:00:00   |
|        5 | u0001   |    900 | 2018-01-20 00:00:00 | 2018-01-01 00:00:00    | 2018-01-20 00:00:00   |
|        6 | u0002   |    500 | 2018-01-05 00:00:00 | 2018-01-05 00:00:00    | 2018-01-22 00:00:00   |
|        7 | u0002   |    600 | 2018-01-06 00:00:00 | 2018-01-05 00:00:00    | 2018-01-22 00:00:00   |
|        8 | u0002   |    300 | 2018-01-10 00:00:00 | 2018-01-05 00:00:00    | 2018-01-22 00:00:00   |
|        9 | u0002   |    800 | 2018-01-16 00:00:00 | 2018-01-05 00:00:00    | 2018-01-22 00:00:00   |
|       10 | u0002   |    800 | 2018-01-22 00:00:00 | 2018-01-05 00:00:00    | 2018-01-22 00:00:00   |
+----------+---------+--------+---------------------+------------------------+-----------------------+
```



## 4. 应用场景

> 使用 Hive SQL 的窗口函数进行商务数据分析 [Jmx's Blog](https://jiamaoxiang.top/2020/09/07/%E4%BD%BF%E7%94%A8Hive-SQL%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%95%86%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/)

窗口函数可满足以下 5 类分析需求：

- 需求 1：收入增长
- 需求 2：累计求和

- 需求 3：处理重复数据

- 需求 4：分组取 Top N

- 需求 5：重复购买行为

![shejiyeiconthphylmdhxo](https://i.loli.net/2020/10/30/FpvrnY6Zcam9Msw.png)

## 5. 参考

- SQL 基础教程（第 2 版）- MICK (作者) 孙淼 , 罗勇 (译者)  **# 深入浅出的入门教材**
- MySQL 窗口函数 https://tding.top/archives/c6e31643.html
- MySQL 8.0 新特性 https://dev.mysql.com/doc/refman/8.0/en/
- PARTITION BY 和 GROUP BY 的区别 https://www.itranslater.com/qa/details/2108912919936238592
- 使用 Hive SQL 的窗口函数进行商务数据分析  [Jmx's Blog](https://jiamaoxiang.top/2020/09/07/%E4%BD%BF%E7%94%A8Hive-SQL%E7%9A%84%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%95%86%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/) # 实际应用 
- 1
